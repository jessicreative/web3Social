var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { utils } from 'ethers';
import { PrivateKeyBundleV1, decodePrivateKeyBundle, decrypt, encrypt, } from '../crypto';
import { Authenticator } from '../authn';
import { bytesToHex, getRandomValues, hexToBytes } from '../crypto/utils';
import Ciphertext from '../crypto/Ciphertext';
import { privateKey as proto } from '@xmtp/proto';
const KEY_BUNDLE_NAME = 'key_bundle';
/**
 * EncryptedKeyStore wraps Store to enable encryption of private key bundles
 * using a wallet signature.
 */
export default class EncryptedKeyStore {
    constructor(signer, store) {
        this.signer = signer;
        this.store = store;
    }
    getStorageAddress(name) {
        return __awaiter(this, void 0, void 0, function* () {
            // I think we want to namespace the storage address by wallet
            // This will allow us to support switching between multiple wallets in the same browser
            const walletAddress = yield this.signer.getAddress();
            return `${walletAddress}/${name}`;
        });
    }
    // Retrieve a private key bundle for the active wallet address in the signer
    loadPrivateKeyBundle() {
        return __awaiter(this, void 0, void 0, function* () {
            const storageBuffer = yield this.store.get(yield this.getStorageAddress(KEY_BUNDLE_NAME));
            if (!storageBuffer) {
                return null;
            }
            const [bundle, needsUpdate] = yield this.fromEncryptedBytes(this.signer, Uint8Array.from(storageBuffer));
            // If a versioned bundle is not found, the legacy bundle needs to be resaved to the store in
            // the new format. Once all bundles have been upgraded, this migration code can be removed.
            if (needsUpdate) {
                yield this.storePrivateKeyBundle(bundle);
            }
            return bundle;
        });
    }
    // Store the private key bundle at an address generated based on the active wallet in the signer
    storePrivateKeyBundle(bundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyAddress = yield this.getStorageAddress(KEY_BUNDLE_NAME);
            const encodedBundle = yield this.toEncryptedBytes(bundle, this.signer);
            // We need to setup the Authenticator so that the underlying store can publish messages without error
            if (typeof this.store.setAuthenticator === 'function') {
                this.store.setAuthenticator(new Authenticator(bundle.identityKey));
            }
            yield this.store.set(keyAddress, Buffer.from(encodedBundle));
        });
    }
    // encrypts/serializes the bundle for storage
    toEncryptedBytes(bundle, wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            // serialize the contents
            const bytes = bundle.encode();
            const wPreKey = getRandomValues(new Uint8Array(32));
            const input = storageSigRequestText(wPreKey);
            const walletAddr = yield wallet.getAddress();
            let sig = yield wallet.signMessage(input);
            // Check that the signature is correct, was created using the expected
            // input, and retry if not. This mitigates a bug in interacting with
            // LedgerLive for iOS, where the previous signature response is
            // returned in some cases.
            let address = utils.verifyMessage(input, sig);
            if (address !== walletAddr) {
                sig = yield wallet.signMessage(input);
                console.log('invalid signature, retrying');
                address = utils.verifyMessage(input, sig);
                if (address !== walletAddr) {
                    throw new Error('invalid signature');
                }
            }
            const secret = hexToBytes(sig);
            const ciphertext = yield encrypt(bytes, secret);
            return proto.EncryptedPrivateKeyBundle.encode({
                v1: {
                    walletPreKey: wPreKey,
                    ciphertext,
                },
            }).finish();
        });
    }
    // decrypts/deserializes the bundle from storage bytes
    fromEncryptedBytes(wallet, bytes) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [eBundle, needsUpdate] = getEncryptedBundle(bytes);
            if (!eBundle.walletPreKey) {
                throw new Error('missing wallet pre-key');
            }
            if (!((_a = eBundle.ciphertext) === null || _a === void 0 ? void 0 : _a.aes256GcmHkdfSha256)) {
                throw new Error('missing bundle ciphertext');
            }
            const secret = hexToBytes(yield wallet.signMessage(storageSigRequestText(eBundle.walletPreKey)));
            const ciphertext = new Ciphertext(eBundle.ciphertext);
            const decrypted = yield decrypt(ciphertext, secret);
            const [bundle, needsUpdate2] = getPrivateBundle(decrypted);
            return [bundle, needsUpdate || needsUpdate2];
        });
    }
}
// getEncryptedV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts
// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.
function getEncryptedBundle(bytes) {
    try {
        const b = proto.EncryptedPrivateKeyBundle.decode(bytes);
        if (b.v1) {
            return [b.v1, false];
        }
    }
    catch (e) {
        return [proto.EncryptedPrivateKeyBundleV1.decode(bytes), true];
    }
    throw new Error('unrecognized encrypted private key bundle version');
}
// getPrivateV1Bundle returns the decoded bundle from the provided bytes. If there is an error decoding the bundle it attempts
// to decode the bundle as a legacy bundle. Additionally return whether the bundle is in the expected format.
function getPrivateBundle(bytes) {
    try {
        // TODO: add support for V2
        const b = decodePrivateKeyBundle(bytes);
        return [b, false];
    }
    catch (e) {
        // Adds a default fallback for older versions of the proto
        const b = proto.PrivateKeyBundleV1.decode(bytes);
        return [new PrivateKeyBundleV1(b), true];
    }
}
export function storageSigRequestText(preKey) {
    // Note that an update to this signature request text will require
    // addition of backward compatibility for existing encrypted bundles
    // and/or a migration; otherwise clients will no longer be able to
    // decrypt those bundles.
    return ('XMTP : Enable Identity\n' +
        `${bytesToHex(preKey)}\n` +
        '\n' +
        'For more info: https://xmtp.org/signatures/');
}
//# sourceMappingURL=EncryptedStore.js.map