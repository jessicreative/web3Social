import { publicKey } from '@xmtp/proto';
import Long from 'long';
import Signature from './Signature';
import { Signer } from 'ethers';
declare type secp256k1Uncompressed = {
    bytes: Uint8Array;
};
export declare class UnsignedPublicKey implements publicKey.UnsignedPublicKey {
    createdNs: Long;
    secp256k1Uncompressed: secp256k1Uncompressed;
    constructor(obj: publicKey.UnsignedPublicKey);
    generated(): Date | undefined;
    get timestamp(): Long;
    verify(signature: Signature, digest: Uint8Array): boolean;
    verifyKey(pub: PublicKey | SignedPublicKey): Promise<boolean>;
    equals(other: this): boolean;
    getEthereumAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): UnsignedPublicKey;
}
export declare class SignedPublicKey extends UnsignedPublicKey implements publicKey.SignedPublicKey {
    keyBytes: Uint8Array;
    signature: Signature;
    constructor(obj: publicKey.SignedPublicKey);
    get unsignedKey(): UnsignedPublicKey;
    signerKey(): Promise<UnsignedPublicKey | undefined>;
    walletSignatureAddress(): Promise<string>;
    equals(other: this): boolean;
    bytesToSign(): Uint8Array;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): SignedPublicKey;
    static fromLegacyKey(legacyKey: PublicKey, signedByWallet?: boolean): SignedPublicKey;
}
export declare class PublicKey extends UnsignedPublicKey implements publicKey.PublicKey {
    signature?: Signature;
    constructor(obj: publicKey.PublicKey);
    get timestamp(): Long;
    bytesToSign(): Uint8Array;
    signWithWallet(wallet: Signer): Promise<void>;
    walletSignatureAddress(): string;
    toBytes(): Uint8Array;
    static fromBytes(bytes: Uint8Array): PublicKey;
}
export {};
