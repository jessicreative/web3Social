import type { Conversation } from './conversations/Conversation';
import type Client from './Client';
import { xmtpEnvelope as proto } from '@xmtp/proto';
import Ciphertext from './crypto/Ciphertext';
import { PublicKeyBundle, PrivateKeyBundleV1 } from './crypto';
import { ContentTypeId } from './MessageContent';
declare class MessageBase {
    headerBytes: Uint8Array;
    ciphertext: Ciphertext;
    contentType?: ContentTypeId;
    error?: Error;
    /**
     * Identifier that is deterministically derived from the bytes of the message
     * header and ciphertext, where all those bytes are authenticated. This can
     * be used in determining uniqueness of messages.
     */
    id: string;
    private bytes;
    constructor(id: string, bytes: Uint8Array, obj: proto.Message);
    toBytes(): Uint8Array;
}
export declare class MessageV1 extends MessageBase implements proto.MessageV1 {
    header: proto.MessageHeaderV1;
    senderAddress: string | undefined;
    conversation: undefined;
    constructor(id: string, bytes: Uint8Array, obj: proto.Message, header: proto.MessageHeaderV1, senderAddress: string | undefined);
    static create(obj: proto.Message, header: proto.MessageHeaderV1, bytes: Uint8Array): Promise<MessageV1>;
    get sent(): Date;
    get recipientAddress(): string | undefined;
    static encode(sender: PrivateKeyBundleV1, recipient: PublicKeyBundle, message: Uint8Array, timestamp: Date): Promise<MessageV1>;
    static fromBytes(bytes: Uint8Array): Promise<MessageV1>;
    decrypt(viewer: PrivateKeyBundleV1): Promise<Uint8Array>;
}
export declare class MessageV2 extends MessageBase implements proto.MessageV2 {
    senderAddress: string | undefined;
    private header;
    private signed?;
    constructor(id: string, bytes: Uint8Array, obj: proto.Message, header: proto.MessageHeaderV2, signed: proto.SignedContent, senderAddress: string);
    static create(obj: proto.Message, header: proto.MessageHeaderV2, signed: proto.SignedContent, bytes: Uint8Array): Promise<MessageV2>;
    get sent(): Date;
}
export declare type Message = MessageV1 | MessageV2;
export declare class DecodedMessage {
    id: string;
    messageVersion: 'v1' | 'v2';
    senderAddress: string;
    recipientAddress?: string;
    sent: Date;
    contentTopic: string;
    conversation: Conversation;
    contentType: ContentTypeId;
    content: any;
    error?: Error;
    constructor({ id, messageVersion, senderAddress, recipientAddress, conversation, contentType, contentTopic, content, sent, error, }: DecodedMessage);
    static fromV1Message(message: MessageV1, content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType: ContentTypeId, contentTopic: string, conversation: Conversation, error?: Error): DecodedMessage;
    static fromV2Message(message: MessageV2, content: any, // eslint-disable-line @typescript-eslint/no-explicit-any
    contentType: ContentTypeId, contentTopic: string, conversation: Conversation, error?: Error): DecodedMessage;
}
export declare function decodeContent(contentBytes: Uint8Array, client: Client): {
    content: any;
    contentType: ContentTypeId;
    error: Error | undefined;
};
export {};
